local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer

if not game:IsLoaded() then
	game.Loaded:Wait()
end

-- Wait for required remotes
local endpoints = ReplicatedStorage:WaitForChild("endpoints")
local serverToClient = endpoints:WaitForChild("server_to_client")
local clientToServer = endpoints:WaitForChild("client_to_server")

local Cards = serverToClient:WaitForChild("Cards")
local CardAction = clientToServer:WaitForChild("CardAction")

print("[READY] Waiting for Cards.OnClientEvent...")

-- Define card priority
local PRIORITY = {
	["Damage Tier 3"] = 1,
	["Damage Tier 2"] = 2,
	["Damage Tier 1"] = 3,
	["Range Tier 3"] = 4,
	["Range Tier 2"] = 5,
	["Range Tier 1"] = 6,
	["Cooldown Tier 3"] = 7,
	["Cooldown Tier 2"] = 8,
	["Cooldown Tier 1"] = 9,
	["Tier 3 Trade Off"] = 10,
	["Tier 2 Trade Off"] = 11,
	["Tier 1 Trade Off"] = 12,
}

-- Function to select card
local function selectBestCard(cards)
	print("[INFO] Cards received:", #cards)

	local bestIndex, bestPriority = nil, math.huge

	for i, card in ipairs(cards) do
		local effect = card.Effects and card.Effects[1]
		if effect then
			local name = effect.Name
			local priority = PRIORITY[name] or 999
			print(string.format("[DEBUG] Card %d: %s (priority %d)", i, name, priority))

			if priority < bestPriority then
				bestPriority = priority
				bestIndex = i
			end
		else
			print("[WARN] Card", i, "has no Effects")
		end
	end

	if bestIndex then
		print(string.format("[SELECT] Choosing card #%d with priority %d", bestIndex, bestPriority))
		task.wait(0.5)
		pcall(function()
			CardAction:FireServer(bestIndex)
		end)
	else
		warn("[ERROR] No valid cards found to choose")
	end
end

-- Listen for the card selection event
Cards.OnClientEvent:Connect(function(eventType, data)
	print("[EVENT] Cards.OnClientEvent received:", eventType)
	if eventType == "StartSelection" then
		selectBestCard(data)
	end
end)
